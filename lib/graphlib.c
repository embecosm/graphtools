/* -*- mode: C; c-file-style: "gnu"; fill-column: 78; -*-
   graphlib.c - library of routines common to graphtools programs

   Copyright (C) 2012 Embecosm Limited

   Contributor Jeremy Bennett <jeremy.bennett@embecosm.com>

   This file is part of Embecosm graphtools

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.

   *************************************************************************

   Functions to help in manipulating GraphViz DOT files (as generated by
   Verilator).

   Typically we are creating subgraphs of an original graph, but for which we
   wish to preserve the attributes of the graph, nodes and edges.

   When considering directed graphs, remember the GraphViz cgraph library
   uses the following naming:

     tail -> head */

#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "graphtools.h"


/*! Clone one set of attributes of the old graph.

    Clone the string attributes of a particular kind (AGRAPH, AGNODE or
    AGEDGE) from one graph into a new graph.

    Create two null terminated vectors of attributes of a particular kind. One
    vector for the attributes in the old graph, one for the same attributes
    added to the new graph.

    @note If the old or new attribute structures have already been used for
          cloning, the old data will be thrown away, but not deleted. Potential
          memory leak.

    @param [in]  og                 Old graph
    @param [in]  ng                 New graph
    @param [out] old_attrs_vec_ptr  Vector for attributes in old graph
    @param [out] new_attrs_vec_ptr  Vector for attributes added to new graph
    @param [in]  kind               Kind of attributes to clone. */
static void
clone_attributes_kind (Agraph_t   *og,
		       Agraph_t   *ng,
		       Agsym_t  ***old_attrs_vec_ptr,
		       Agsym_t  ***new_attrs_vec_ptr,
		       int         kind)
{
  int  n = 0;
  Agsym_t *a;

  /* Find out how many node attributes and alloc space for them. */
  for (a = agnxtattr (og, kind, NIL (Agsym_t *));
       a != NULL;
       a = agnxtattr (og, kind, a))
    {
      n++;
    }

  n++;					/* Space for NULL on the end */
  *new_attrs_vec_ptr = (Agsym_t **) calloc (sizeof (Agsym_t *), n);
  *old_attrs_vec_ptr = (Agsym_t **) calloc (sizeof (Agsym_t *), n);

  /* Add the attributes to the new graph */
  n = 0;
  for (a = agnxtattr (og, kind, NIL (Agsym_t *));
       a != NULL;
       a = agnxtattr (og, kind, a))
    {
      *old_attrs_vec_ptr[n] = a;
      *new_attrs_vec_ptr[n] = agattr (ng, kind, a->name, "");
      n++;
    }

  *old_attrs_vec_ptr[n] = NULL;		/* end marker */
  *new_attrs_vec_ptr[n] = NULL;		/* end marker */

}	/* clone_attributes_kind */


/*! Clone all the attributes of the old graph.

    Clone the string attributes of each kind (AGRAPH, AGNODE or AGEDGE) from
    one graph into a new graph.

    For each kind, create two null terminated vectors of attributes. One
    vector for the attributes in the old graph, one for the same attributes
    added to the new graph.

    @note If the old or new attribute structures have already been used for
          cloning, the old data will be thrown away, but not deleted. Potential
          memory leak.

    @param [in]  og         Old graph
    @param [in]  ng         New graph
    @param [out] old_attrs  Structure for attributes in old graph
    @param [out] new_attrs  Structure for attributes added to new graph */
void
clone_attributes (Agraph_t   *og,
		  Agraph_t   *ng,
		  All_attr_t *old_attrs,
		  All_attr_t *new_attrs)
{
  /* Get the attributes of each kind. */
  clone_attributes_kind (og, ng, &(old_attrs->graph_attrs),
			 &(new_attrs->graph_attrs), AGRAPH);
  clone_attributes_kind (og, ng, &(old_attrs->node_attrs),
			 &(new_attrs->node_attrs), AGNODE);
  clone_attributes_kind (og, ng, &(old_attrs->edge_attrs),
			 &(new_attrs->edge_attrs), AGEDGE);

}	/* clone_attributes */


/*! Add a clone of one node to a graph with all its attributes.

    @param [in] g          Graph to add to
    @param [in] nodep      Orignal node to clone
    @param [in] old_attrs  Structure holding attributes for original node
    @param [in] new_attrs  Structure holding attributes for new node

    @return  The cloned node */
Agnode_t *
clone_node (Agraph_t   *g,
	    Agnode_t   *nodep,
	    All_attr_t *old_attrs,
	    All_attr_t *new_attrs)
{
  Agnode_t *new_nodep = agnode (g, agnameof (nodep), TRUE);
  int  i;

  /* Set all the attributes. We know already that these attributes are
     permitted, so we don't need to use safeset! */
  for (i = 0; old_attrs->node_attrs[i] != NULL; i++)
    {
      agxset (new_nodep, new_attrs->node_attrs[i],
	      agxget (nodep, old_attrs->node_attrs[i]));
    }

  return new_nodep;

}	/* clone_node () */


/*! Add a clone of one edge to a graph with all its attributes.

    @param [in] g          Graph to add to
    @param [in] edgep      Orignal edge to clone
    @param [in] tailp      Tail node of the edge
    @param [in] headp      Head node of the edge
    @param [in] old_attrs  Structure holding attributes for original edge
    @param [in] new_attrs  Structure holding attributes for new edge

    @return  The cloned edge */
Agedge_t *
clone_edge (Agraph_t *g,
	    Agedge_t *edgep,
	    Agnode_t *tailp,
	    Agnode_t *headp,
	    All_attr_t *old_attrs,
	    All_attr_t *new_attrs)
{
  Agedge_t *new_edgep = agedge (g, tailp, headp, agnameof (edgep), TRUE);
  int  i;

  /* Set all the attributes. We know already that these attributes are
     permitted, so we don't need to use safeset! */
  for (i = 0; old_attrs->edge_attrs[i] != NULL; i++)
    {
      agxset (new_edgep, new_attrs->edge_attrs[i],
	      agxget (edgep, old_attrs->edge_attrs[i]));
    }

  return new_edgep;

}	/* clone_edge () */


/*! Check if attributes match

    The supplied match list includes values of attributes that must match or
    not. We check that all the criteria are met for the supplied object.

    @param [in] obj   The object to check
    @param [in] kind  The kind of object (AGEDGE, AGNODE)
    @param [in] amp   The match list

    @return  TRUE if all attribute match/don't match as required, FALSE
    otherwise */
int
check_attributes (void         *objp,
		  int           kind,
		  Attr_match_t *amp)
{
  for (; amp != NULL; amp = amp->next)
    {
      if (amp->kind == kind)
	{
	  char *val = agxget (objp, amp->attr);

	  if (amp->matchit
	      ? 0 != strcmp (amp->value, val)
	      : 0 == strcmp (amp->value, val))
	    {
	      return FALSE;
	    }
	}
    }

  return  TRUE;

}	/* check_attributes () */


/*! Extend the label of a graph.

    A second line is added to the label with the supplied text

    @param[in] g    Graph
    @param[in] str  Text to add to the new graph. */
void
label_extend_graph (Agraph_t *g,
		    char     *str)
{
  Agsym_t *a      = agattr (g, AGRAPH, "label", "");
  char    *val    = agxget (g, a);
  char    *newval = malloc (snprintf (NULL, 0, "%s\\n%s", val, str) + 1);

  sprintf (newval, "%s\\n%s", val, str);
  agsafeset (g, a->name, newval, "");

}	/* label_extend_graph () */
