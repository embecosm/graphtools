/* -*- mode: C; c-file-style: "gnu"; fill-column: 78; -*-
   graphlib.c - library of routines common to graphtools programs

   Copyright (C) 2012 Embecosm Limited

   Contributor Jeremy Bennett <jeremy.bennett@embecosm.com>

   This file is part of Embecosm graphtools

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.

   *************************************************************************

   Functions to help in manipulating GraphViz DOT files (as generated by
   Verilator).

   Typically we are creating subgraphs of an original graph, but for which we
   wish to preserve the attributes of the graph, nodes and edges.

   When considering directed graphs, remember the GraphViz cgraph library
   uses the following naming:

     tail -> head */

#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "graphtools.h"


/*! Clone one set of attributes of the old graph.

    Clone the string attributes of a particular kind (AGRAPH, AGNODE or
    AGEDGE) from one graph into a new graph.

    Create two null terminated vectors of attributes of a particular kind. One
    vector for the attributes in the old graph, one for the same attributes
    added to the new graph.

    Note that we don't do all kinds at once, since in some circumstances we
    may not need all kinds.

    @note If the old or new attribute structures have already been used for
          cloning, the old data will be thrown away, but not deleted. Potential
          memory leak.

    @param [in]  og         Old graph
    @param [in]  ng         New graph
    @param [out] old_attrs  Structure for attributes in old graph
    @param [out] new_attrs  Structure for attributes added to new graph
    @param [in]  kind       Kind of attributes to clone. */
void
clone_attributes (Agraph_t   *g,
		  Agraph_t   *ng,
		  All_attr_t *old_attrs,
		  All_attr_t *new_attrs,
		  int         kind)
{
  int  n = 0;
  Agsym_t *a;

  /* Find out how many node attributes and alloc space for them. */
  for (a = agnxtattr (g, kind, NIL (Agsym_t *));
       a != NULL;
       a = agnxtattr (g, kind, a))
    {
      n++;
    }

  n++;					/* Space for NULL on the end */
  Agsym_t **new_attrs_kind = (Agsym_t **) calloc (sizeof (*new_attrs_kind), n);
  Agsym_t **old_attrs_kind = (Agsym_t **) calloc (sizeof (*old_attrs_kind), n);

  /* Add the attributes to the new graph */
  n = 0;
  for (a = agnxtattr (g, kind, NIL (Agsym_t *));
       a != NULL;
       a = agnxtattr (g, kind, a))
    {
      old_attrs_kind[n] = a;
      new_attrs_kind[n] = agattr (ng, kind, a->name, "");
      n++;
    }

  old_attrs_kind[n] = NULL;		/* end marker */
  new_attrs_kind[n] = NULL;		/* end marker */

  switch (kind)
    {
    case AGRAPH:
      old_attrs->graph_attrs = old_attrs_kind;
      new_attrs->graph_attrs = new_attrs_kind;
      break;

    case AGNODE:
      old_attrs->node_attrs = old_attrs_kind;
      new_attrs->node_attrs = new_attrs_kind;
      break;

    case AGEDGE:
      old_attrs->edge_attrs = old_attrs_kind;
      new_attrs->edge_attrs = new_attrs_kind;
      break;

    default:
      fprintf (stderr, "Warning: cloning unknown attribute kind %d\n", kind);
      break;
    }
}	/* clone_attributes */


/*! Add a clone of one node to a graph with all its attributes.

    @param [in] g          Graph to add to
    @param [in] nodep      Orignal node to clone
    @param [in] old_attrs  Structure holding attributes for original node
    @param [in] new_attrs  Structure holding attributes for new node

    @return  The cloned node */
Agnode_t *
clone_node (Agraph_t   *g,
	    Agnode_t   *nodep,
	    All_attr_t *old_attrs,
	    All_attr_t *new_attrs)
{
  Agnode_t *new_nodep = agnode (g, agnameof (nodep), TRUE);
  int  i;

  /* Set all the attributes. We know already that these attributes are
     permitted, so we don't need to use safeset! */
  for (i = 0; old_attrs->node_attrs[i] != NULL; i++)
    {
      agxset (new_nodep, new_attrs->node_attrs[i],
	      agxget (nodep, old_attrs->node_attrs[i]));
    }

  return new_nodep;

}	/* clone_node () */


/*! Add a clone of one edge to a graph with all its attributes.

    @param [in] g          Graph to add to
    @param [in] edgep      Orignal edge to clone
    @param [in] tailp      Tail node of the edge
    @param [in] headp      Head node of the edge
    @param [in] old_attrs  Structure holding attributes for original edge
    @param [in] new_attrs  Structure holding attributes for new edge

    @return  The cloned edge */
Agedge_t *
clone_edge (Agraph_t *g,
	    Agedge_t *edgep,
	    Agnode_t *tailp,
	    Agnode_t *headp,
	    All_attr_t *old_attrs,
	    All_attr_t *new_attrs)
{
  Agedge_t *new_edgep = agedge (g, tailp, headp, agnameof (edgep), TRUE);
  int  i;

  /* Set all the attributes. We know already that these attributes are
     permitted, so we don't need to use safeset! */
  for (i = 0; old_attrs->edge_attrs[i] != NULL; i++)
    {
      agxset (new_edgep, new_attrs->edge_attrs[i],
	      agxget (edgep, old_attrs->edge_attrs[i]));
    }

  return new_edgep;

}	/* clone_edge () */


/*! Check if attributes match

    The supplied match list includes values of attributes that must match or
    not. We check that all the criteria are met for the supplied object.

    @param [in] obj   The object to check
    @param [in] kind  The kind of object (AGEDGE, AGNODE)
    @param [in] amp   The match list

    @return  TRUE if all attribute match/don't match as required, FALSE
    otherwise */
int
check_attributes (void         *objp,
		  int           kind,
		  Attr_match_t *amp)
{
  int  res = TRUE;

  for (; amp != NULL; amp = amp->next)
    {
      if (amp->kind == kind)
	{
	  char *val = agxget (objp, amp->attr);

	  if (amp->matchit
	      ? 0 != strcmp (amp->value, val)
	      : 0 == strcmp (amp->value, val))
	    {
	      return FALSE;
	    }
	}
    }

  return  TRUE;

}	/* check_attributes () */
