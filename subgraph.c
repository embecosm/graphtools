/* Simple DOT graph manipulation program.

   Copyright (C) 2012 Embecosm Limited

   Contributor Jeremy Bennett <jeremy.bennett@embecosm.com>

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.

   *************************************************************************

   Take DOT files (as generated by Verilator) and manipulate them in a number
   of ways.

   For Usage see the usage () function below.

   When considering directed graphs, remember the GraphViz cgraph library
   uses the following naming:

     tail -> head */

#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <graphviz/cgraph.h>


/*! A structure for attribute matching */
struct attr_match
{
  char              *name;
  int                matchit;		/*!< Bool whether to match/not match */
  int                kind;		/*!< AGNODE or AGEDGE */
  Agsym_t           *attr;		/*!< attribute in old graph */
  char              *value;		/*!< value to match */
  struct attr_match *next;		/*!< Hold as linked list */
};

typedef struct attr_match Attr_match_t;


/* All the attributes held by nodes and edges of the original graph. Compute
   once for efficiency and NULL terminate the lists. */
static Agsym_t **old_node_attrs;	/*!< Node attributes in old graph */
static Agsym_t **new_node_attrs;	/*!< Node attributes in new graph */
static Agsym_t **old_edge_attrs;	/*!< Edge attributes in old graph */
static Agsym_t **new_edge_attrs;	/*!< Edge attributes in new graph */


/*! Clone one set of attributes of the old graph.

    Clone the string attributes of a particular kind from one graph into a new
    graph.

    Create two vectors of attributes of a particular kind. One vector for the
    attributes in the old graph, one for the same attributes added to the new
    graph.

    @param [in]  g          Old graph
    @param [in]  ng         New graph
    @param [out] old_attrs  Vector of attributes in old graph
    @param [out] new_attrs  Vector of attributes added to new graph
    @param [in]  kind       King of attributes to clone. */
static void
clone_attributes (Agraph_t   *g,
		  Agraph_t   *ng,
		  Agsym_t  ***old_attrs,
		  Agsym_t  ***new_attrs,
		  int         kind)
{
  int  n = 0;
  Agsym_t *a;

  /* Find out how many node attributes and alloc space for them. */
  for (a = agnxtattr (g, kind, NIL (Agsym_t *));
       a != NULL;
       a = agnxtattr (g, kind, a))
    {
      n++;
    }

  n++;					/* Space for NULL on the end */
  *new_attrs = (Agsym_t **) malloc (n * sizeof (**new_attrs));
  *old_attrs = (Agsym_t **) malloc (n * sizeof (**old_attrs));

  /* Add the attributes to the new graph */
  n = 0;
  for (a = agnxtattr (g, kind, NIL (Agsym_t *));
       a != NULL;
       a = agnxtattr (g, kind, a))
    {
      (*old_attrs)[n] = a;
      (*new_attrs)[n] = agattr (ng, kind, a->name, "");
      n++;
    }

  (*old_attrs)[n] = NULL;		/* end marker */
  (*new_attrs)[n] = NULL;		/* end marker */

}	/* clone_attributes */


/*! Add a clone of one node to a graph with all its attributes.

    @param [in] g      Graph to add to
    @param [in] nodep  Orignal node to clone

    @return  The cloned node */
static Agnode_t *
add_node (Agraph_t *g,
	  Agnode_t *nodep)
{
  Agnode_t *new_nodep = agnode (g, agnameof (nodep), TRUE);
  int  i;

  /* Set all the attributes. We know already that these attributes are
     permitted, so we don't need to use safeset! */
  for (i = 0; old_node_attrs[i] != NULL; i++)
    {
      agxset (new_nodep, new_node_attrs[i], agxget (nodep, old_node_attrs[i]));
    }

  return new_nodep;

}	/* add_node () */


/*! Add a clone of one edge to a graph with all its attributes.

    @param [in] g      Graph to add to
    @param [in] edgep  Orignal edge to clone
    @param [in] tailp  Tail node of the edge
    @param [in] headp  Head node of the edge

    @return  The cloned edge */
static Agedge_t *
add_edge (Agraph_t *g,
	  Agedge_t *edgep,
	  Agnode_t *tailp,
	  Agnode_t *headp)
{
  Agedge_t *new_edgep = agedge (g, tailp, headp, agnameof (edgep), TRUE);
  int  i;

  /* Set all the attributes. We know already that these attributes are
     permitted, so we don't need to use safeset! */
  for (i = 0; old_edge_attrs[i] != NULL; i++)
    {
      agxset (new_edgep, new_edge_attrs[i], agxget (edgep, old_edge_attrs[i]));
    }

  return new_edgep;

}	/* add_edge () */


/*! Check if attributes match

    The supplied match list includes values of attributes that must match or
    not. We check that all the criteria are met for the supplied object.

    @param [in] obj   The object to check
    @param [in] kind  The kind of object (AGEDGE, AGNODE)
    @param [in] amp   The match list

    @return  TRUE if all attribute match/don't match as required, FALSE
    otherwise */
static int
check_attributes (void         *objp,
		  int           kind,
		  Attr_match_t *amp)
{
  int  res = TRUE;

  for (; amp != NULL; amp = amp->next)
    {
      if (amp->kind == kind)
	{
	  char *val = agxget (objp, amp->attr);

	  if (amp->matchit
	      ? 0 != strcmp (amp->value, val)
	      : 0 == strcmp (amp->value, val))
	    {
	      return FALSE;
	    }
	}
    }

  return  TRUE;

}	/* check_attributes () */


/*! Recursively add nodes to a sub-tree.

    We are only interested in outgoing edges (otherwise we would find the
    original graph). If this node is already added, just return it. Otherwise
    clone the node from the old graph, add all its outgoing edges and recurse
    on their destinations.

    @param [in] g          Old graph
    @param [in] ng         New graph
    @param [in] nodep      Node to be cloned from old to new graph
    @param [in] depth      Depth to continue in the recursion
    @param [in] from_root  TRUE if tree flows from root
    @param [in] amp        List of attributes to match/not match

    @return  The node in the new graph */
static Agnode_t *
add_nodes (Agraph_t     *g,
	   Agraph_t     *ng,
	   Agnode_t     *nodep,
	   int           depth,
	   int           from_root,
	   Attr_match_t *amp)
{
  char *node_name = agnameof (nodep);
  Agnode_t *fromp;

  /* If we haven't seen this node, add it and recurse unless we have hit the
     depth limit. */
  if (NULL == (fromp = agnode (ng, node_name, FALSE)))
    {
      fromp = add_node (ng, nodep);

      if (depth > 0)
	{
	  Agedge_t *edgep;

	  for (edgep = from_root ? agfstout (g, nodep) : agfstin (g, nodep);
	       edgep != NULL;
	       edgep = from_root ? agnxtout (g, edgep) : agnxtin (g, edgep))
	    {
	      Agnode_t *towardp = from_root ? aghead (edgep) : agtail (edgep);

	      /* Only recurse if the edge and toward node meet the attribute
		 requirements. */
	      if (check_attributes (edgep, AGEDGE, amp)
		  && check_attributes (towardp, AGNODE, amp))
		{
		  if (from_root)
		    {
			add_edge (ng, edgep, fromp,
				  add_nodes (g, ng, towardp, depth - 1,
					     from_root, amp));
		    }
		  else
		    {
			add_edge (ng, edgep,
				  add_nodes (g, ng, towardp, depth - 1,
					     from_root, amp), fromp);
		    }
		}
	    }
	}
    }

  return  fromp;

}	/* add_nodes () */


/*! Main program

    @param [in] argc  Number of arguments
    @param [in] argv  Vector of arguments */
int
main(int    argc,
     char **argv)
{
  char *usage = "Usage: %s [-h] | -l <label> | -n <node> [-d <depth>]\n"
    "                [-na <attr_name> <attr_val>] |\n"
    "                [-no-na <attr_name> <attr_val>] |\n"
    "                [-ea <attr_name> <attr_val>] |\n"
    "                [-no-ea <attr_name> <attr_val>] |\n";

  /* Parse any help or info arguments first. */

  if ((NULL == argv[1])
      || (0 == strcmp ("-h", argv[1]))
      || (0 == strcmp ("-help", argv[1]))
      || (0 == strcmp ("--help", argv[1])))
    {
      /* Print help and exit */
      printf (usage, argv[0]);
      printf ("(no arguments)\n");
      printf ("-h\n");
      printf ("-help\n");
      printf ("--help\n\n");
      printf ("    Print this help message\n\n");
      printf ("-l <label>\n\n");
      printf ("    Use the node with this label as root\n\n");
      printf ("-n <node>\n\n");
      printf ("    Use the node with this name as root\n\n");
      printf ("-d <depth>\n\n");
      printf ("    Only print tree below root to this depth\n\n");
      printf ("-na <attr_name> <attr_value\n");
      printf ("-no-na <attr_name> <attr_value\n");
      printf ("-ea <attr_name> <attr_value\n");
      printf ("-no-ena <attr_name> <attr_value\n\n");
      printf ("    Only include nodes or edges with or without the\n");
      printf ("    specified attribute set to the specified value. Node\n");
      printf ("    attributes indicate by \"-na\", edge attributes by\n");
      printf ("    \"-ea\". \"no-\" indicates the attribute should *not*\n");
      printf ("    match\n\n");
      printf ("-from-root\n\n");
      printf ("    The tree is built using edges that flow from the root,\n");
      printf ("    i.e the root is the tail (default)\n\n");
      printf ("-to-root\n\n");
      printf ("    The tree is built using edges that flow to the root,\n");
      printf ("    i.e the root is the head\n");
      exit (0);
    }

  /* Read the graph *before* we parse the other arguments, so attributes are
     available for us to look up. */
  Agraph_t *g;				/* The whole graph */
  char     *gname = "";			/* Its name */

  if (NULL == (g = agread(stdin, NULL)))
    {
      fprintf (stderr, "ERROR: Failed to read graph\n");
      exit (1);
    }
  else
    {
      gname = agnameof (g);
    }

  /* Parse the arguments */
  char         *root_name = NULL;
  char         *root_label = NULL;
  Attr_match_t *match_listp = NULL;
  int           depth = INT_MAX;
  int           from_root = TRUE;
  int           i;

  for (i = 1; NULL != argv[i]; i++)
    {
      if (0 == strcmp ("-from-root", argv[i]))
	{
	    /* Tree must grow from the root. */
	    from_root = TRUE;
	}
      else if (0 == strcmp ("-to-root", argv[i]))
	{
	    /* Tree must grow towards the root. */
	    from_root = FALSE;
	}
      else if ((argc > (i + 1)) && (0 == strcmp ("-l", argv[i])))
	{
	  /* Label of root node */
	  i++;
	  root_label = argv[i];
	}
      else if ((argc > (i + 1)) && (0 == strcmp ("-n", argv[i])))
	{
	  /* Name of root node */
	  i++;
	  root_name = argv[i];
	}
      else if ((argc > (i + 1)) && (0 == strcmp ("-d", argv[i])))
	{
	  /* How far to recurse below root node (depth 0 just does the
	     root) */
	  i++;
	  depth = atoi (argv[i]);
	}
      else if ((argc > (i + 1))
	       && ((0 == strcmp ("-na", argv[i]))
		   || (0 == strcmp ("-no-na", argv[i]))
		   || (0 == strcmp ("-ea", argv[i]))
		   || (0 == strcmp ("-no-ea", argv[i]))))
	{
	  /* Attr to match/not match in nodes/edges */
	  Attr_match_t *amp = malloc (sizeof *amp);

	  amp->matchit = strstr (argv[i], "-no") ? FALSE : TRUE;
	  amp->kind = strstr (argv[i], "-na") ? AGNODE : AGEDGE;
	  amp->next = match_listp;
	  match_listp = amp;

	  i++;
	  amp->name = argv[i];

	  /* Look attribute  up in the old graph */
	  if (amp->attr = agattr (g, amp->kind, amp->name, NULL))
	    {
	      /* Valid attribute, add its value */
	      i++;
	      amp->value = argv[i];
	    }
	  else
	    {
	      i++;
	      fprintf (stderr,
		       "Warning: Invalid attribute match \"%s\" - ignored\n",
		       amp->name);
	      fprintf (stderr, "kind %s, attr %p\n",
		       amp->kind == AGNODE ? "node" : "edge", amp->attr);
	      match_listp = amp->next;
	      free (amp);
	    }
	}
      else
	{
	  fprintf (stderr, usage, argv[0]);
	  exit (1);
	}
    }

  /* Find the desired root node label. */
  Agnode_t *rootp = NULL;
  Agnode_t *nodep;

  for (nodep = agfstnode (g); nodep != NULL; nodep = agnxtnode (g, nodep))
    {
      if (root_name && (0 == strcmp (agnameof (nodep), root_name)))
	{
	  rootp = nodep;
	  break;
	}
      else if (root_label && (0 == strcmp (agget (nodep, "label"), root_label)))
	{
	  rootp = nodep;
	  break;
	}
    }

  if (!rootp)
    {
      fprintf (stderr, "ERROR: Failed to find root node %s\n", root_label);
      exit (1);
    }

  /* Create a new graph, add all the node and edge attributes from the old
     graph. */
  char *ngname = malloc (snprintf (NULL, 0, "%s_%s", gname, root_label) + 1);
  Agraph_t *ng;

  sprintf (ngname, "%s_%s", gname, root_label);
  ng = agopen (ngname, g->desc, NULL);

  /* Make tables of all the attributes for nodes and edges */
  clone_attributes (g, ng, &old_node_attrs, &new_node_attrs, AGNODE);
  clone_attributes (g, ng, &old_edge_attrs, &new_edge_attrs, AGEDGE);

  /* Copy the graph attributes */
  Agsym_t *a;

  for (a = agnxtattr (g, AGRAPH, NIL (Agsym_t *));
       a != NULL;
       a = agnxtattr (g, AGRAPH, a))
    {
      agsafeset (ng, a->name, agxget (g, a), "");
    }

  /* Start at the root node and find all the nodes deriving from it, adding
     those nodes and the edges connecting them to the graph. Then write out
     the graph. */
  (void) add_nodes (g, ng, rootp, depth, from_root, match_listp);
  agwrite (ng, stdout);

}	/* main () */
