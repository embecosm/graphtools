/* Simple DOT graph manipulation program.

   Copyright (C) 2012 Embecosm Limited

   Contributor Jeremy Bennett <jeremy.bennett@embecosm.com>

   This file is part of Embecosm graphtools

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.

   *************************************************************************

   Take DOT files (as generated by Verilator) and find the subgraph from (or
   to) one node.

   For Usage see the usage () function below.

   When considering directed graphs, remember the GraphViz cgraph library
   uses the following naming:

     tail -> head */

#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "graphtools.h"


/* All the attributes held by original and new graphs. */
static All_attr_t old_attrs;		/*!< Attributes in old graph */
static All_attr_t new_attrs;		/*!< Attributes in new graph */


/*! Recursively add nodes to a sub-tree.

    We are only interested in outgoing edges (otherwise we would find the
    original graph). If this node is already added, just return it. Otherwise
    clone the node from the old graph, add all its outgoing edges and recurse
    on their destinations.

    @param [in] ogp        Old graph
    @param [in] ngp        New graph
    @param [in] nodep      Node to be cloned from old to new graph
    @param [in] depth      Depth to continue in the recursion
    @param [in] from_root  TRUE if tree flows from root
    @param [in] amp        List of attributes to match/not match

    @return  The node in the new graph */
static Agnode_t *
add_nodes (Agraph_t     *ogp,
	   Agraph_t     *ngp,
	   Agnode_t     *nodep,
	   int           depth,
	   int           from_root,
	   Attr_match_t *amp)
{
  char *node_name = agnameof (nodep);
  Agnode_t *fromp;

  /* If we haven't seen this node, add it and recurse unless we have hit the
     depth limit. */
  if (NULL == (fromp = agnode (ngp, node_name, FALSE)))
    {
      fromp = clone_node (ngp, nodep, &old_attrs, &new_attrs);

      if (depth > 0)
	{
	  Agedge_t *edgep;

	  for (edgep = from_root ? agfstout (ogp, nodep) : agfstin (ogp, nodep);
	       edgep != NULL;
	       edgep = from_root ? agnxtout (ogp, edgep) : agnxtin (ogp, edgep))
	    {
	      Agnode_t *towardp = from_root ? aghead (edgep) : agtail (edgep);

	      /* Only recurse if the edge and toward node meet the attribute
		 requirements. */
	      if (check_attributes (edgep, AGEDGE, amp)
		  && check_attributes (towardp, AGNODE, amp))
		{
		  if (from_root)
		    {
		      clone_edge (ngp, edgep, fromp,
				  add_nodes (ogp, ngp, towardp, depth - 1,
					     from_root, amp),
				  &old_attrs, &new_attrs);
		    }
		  else
		    {
		      clone_edge (ngp, edgep,
				  add_nodes (ogp, ngp, towardp, depth - 1,
					     from_root, amp), fromp,
				  &old_attrs, &new_attrs);
		    }
		}
	    }
	}
    }

  return  fromp;

}	/* add_nodes () */


/*! Main program

    @param [in] argc  Number of arguments
    @param [in] argv  Vector of arguments */
int
main(int    argc,
     char **argv)
{
  char *usage = "Usage: %s [-h] | -l <label> | -n <node> [-d <depth>]\n"
    "                [-na <attr_name> <attr_val>] |\n"
    "                [-no-na <attr_name> <attr_val>] |\n"
    "                [-ea <attr_name> <attr_val>] |\n"
    "                [-no-ea <attr_name> <attr_val>] |\n";

  /* Parse any help or info arguments first. */

  if ((NULL == argv[1])
      || (0 == strcmp ("-h", argv[1]))
      || (0 == strcmp ("-help", argv[1]))
      || (0 == strcmp ("--help", argv[1])))
    {
      /* Print help and exit */
      printf (usage, argv[0]);
      printf ("(no arguments)\n");
      printf ("-h\n");
      printf ("-help\n");
      printf ("--help\n\n");
      printf ("    Print this help message\n\n");
      printf ("-l <label>\n\n");
      printf ("    Use the node with this label prefix as root\n\n");
      printf ("-n <node>\n\n");
      printf ("    Use the node with this name as root\n\n");
      printf ("-d <depth>\n\n");
      printf ("    Only print tree below root to this depth\n\n");
      printf ("-na <attr_name> <attr_value\n");
      printf ("-no-na <attr_name> <attr_value\n");
      printf ("-ea <attr_name> <attr_value\n");
      printf ("-no-ena <attr_name> <attr_value\n\n");
      printf ("    Only include nodes or edges with or without the\n");
      printf ("    specified attribute set to the specified value. Node\n");
      printf ("    attributes indicate by \"-na\", edge attributes by\n");
      printf ("    \"-ea\". \"no-\" indicates the attribute should *not*\n");
      printf ("    match\n\n");
      printf ("-from-root\n\n");
      printf ("    The tree is built using edges that flow from the root,\n");
      printf ("    i.e the root is the tail (default)\n\n");
      printf ("-to-root\n\n");
      printf ("    The tree is built using edges that flow to the root,\n");
      printf ("    i.e the root is the head\n");
      exit (0);
    }

  /* Read the graph *before* we parse the other arguments, so attributes are
     available for us to look up. */
  Agraph_t *ogp;			/* The whole graph */
  char     *gname = "";			/* Its name */

  if (NULL == (ogp = agread(stdin, NULL)))
    {
      fprintf (stderr, "ERROR: Failed to read graph\n");
      exit (1);
    }
  else
    {
      gname = agnameof (ogp);
    }

  /* Parse the arguments */
  char         *root_name = NULL;
  char         *root_label = NULL;
  Attr_match_t *match_listp = NULL;
  int           depth = INT_MAX;
  int           from_root = TRUE;
  int           i;

  for (i = 1; NULL != argv[i]; i++)
    {
      if (0 == strcmp ("-from-root", argv[i]))
	{
	    /* Tree must grow from the root. */
	    from_root = TRUE;
	}
      else if (0 == strcmp ("-to-root", argv[i]))
	{
	    /* Tree must grow towards the root. */
	    from_root = FALSE;
	}
      else if ((argc > (i + 1)) && (0 == strcmp ("-l", argv[i])))
	{
	  /* Label of root node */
	  i++;
	  root_label = argv[i];
	}
      else if ((argc > (i + 1)) && (0 == strcmp ("-n", argv[i])))
	{
	  /* Name of root node */
	  i++;
	  root_name = argv[i];
	}
      else if ((argc > (i + 1)) && (0 == strcmp ("-d", argv[i])))
	{
	  /* How far to recurse below root node (depth 0 just does the
	     root) */
	  i++;
	  depth = atoi (argv[i]);
	}
      else if ((argc > (i + 1))
	       && ((0 == strcmp ("-na", argv[i]))
		   || (0 == strcmp ("-no-na", argv[i]))
		   || (0 == strcmp ("-ea", argv[i]))
		   || (0 == strcmp ("-no-ea", argv[i]))))
	{
	  /* Attr to match/not match in nodes/edges */
	  Attr_match_t *amp = malloc (sizeof *amp);

	  amp->matchit = strstr (argv[i], "-no") ? FALSE : TRUE;
	  amp->kind = strstr (argv[i], "-na") ? AGNODE : AGEDGE;
	  amp->next = match_listp;
	  match_listp = amp;

	  i++;
	  amp->name = argv[i];

	  /* Look attribute  up in the old graph */
	  if ((amp->attr = agattr (ogp, amp->kind, amp->name, NULL)))
	    {
	      /* Valid attribute, add its value */
	      i++;
	      amp->value = argv[i];
	    }
	  else
	    {
	      i++;
	      fprintf (stderr,
		       "Warning: Invalid attribute match \"%s\" - ignored\n",
		       amp->name);
	      fprintf (stderr, "kind %s, attr %p\n",
		       amp->kind == AGNODE ? "node" : "edge", amp->attr);
	      match_listp = amp->next;
	      free (amp);
	    }
	}
      else
	{
	  fprintf (stderr, usage, argv[0]);
	  exit (1);
	}
    }

  /* Find the desired root node label. */
  Agnode_t *rootp = NULL;
  Agnode_t *nodep;

  for (nodep = agfstnode (ogp); nodep != NULL; nodep = agnxtnode (ogp, nodep))
    {
      if (root_name && (0 == strcmp (agnameof (nodep), root_name)))
	{
	  rootp = nodep;
	  break;
	}
      else if (root_label
	       && (0 == strncmp (agget (nodep, "label"), root_label,
				 strlen(root_label))))
	{
	  rootp = nodep;
	  break;
	}
    }

  if (!rootp)
    {
      fprintf (stderr, "ERROR: Failed to find root node %s\n", root_label);
      exit (1);
    }

  /* Create a new graph, add all the attributes from the old graph and
     labelled appropriately. */
  Agraph_t *ngp;
  char     *ngname = malloc (snprintf (NULL, 0, "%s_subgraph", gname) + 1);

  sprintf (ngname, "%s_subgraph", gname);
  ngp = agopen (ngname, ogp->desc, NULL);

  clone_attributes (ogp, ngp, &old_attrs, &new_attrs);

  /* Copy graph attribute values. */
  for (i = 0; old_attrs.graph_attrs[i]; i++)
    {
      agxset (ngp, new_attrs.graph_attrs[i],
	      agxget (ogp, old_attrs.graph_attrs[i]));
    }

  label_extend_graph (ngp, root_label);

  /* Start at the root node and find all the nodes deriving from it, adding
     those nodes and the edges connecting them to the graph. Then write out
     the graph. */
  (void) add_nodes (ogp, ngp, rootp, depth, from_root, match_listp);
  agwrite (ngp, stdout);

  exit (0);

}	/* main () */
